use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
pub enum TokenKinds {
    /// A sequence of characters
    Token(String),
    /// A string of characters that will be generated by the preprocessor
    Complex(String),
    Text,
    Whitespace,
    Control(ControlTokenKind),
}

#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub enum ControlTokenKind {
    Eof,
    Eol,
}

#[derive(Serialize, Deserialize)]
pub struct Lexer<'a> {
    /// Reference to the text being lexed
    #[serde(skip_serializing, default)]
    pub(crate) text: &'a str,
    /// Possible token kinds
    token_kinds: Vec<String>,
    /// Tokens that have been lexed
    #[serde(skip_serializing, default)]
    pub tokens: Vec<Token>,
}

#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub struct Token {
    /// Index of the token in the text
    pub index: usize,
    /// Length of the token
    pub len: usize,
    /// Location for debugging
    pub location: TextLocation,
    /// Kind of token
    pub kind: TokenKinds,
}

#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[derive(Serialize, Deserialize)]
pub struct TextLocation {
    pub line: usize,
    pub column: usize,
}

impl TextLocation {
    pub fn new(line: usize, column: usize) -> TextLocation {
        let line = line + 1;
        let column = column + 1;
        TextLocation { line, column }
    }
}

impl<'a> Lexer<'a> {
    pub fn new(text: &'a str) -> Lexer<'a> {
        Lexer {
            text,
            token_kinds: Vec::new(),
            tokens: Vec::new(),
        }
    }

    pub fn add_tokens(&mut self, tokens: &[String]) {
        self.token_kinds.reserve(tokens.len());
        for token in tokens {
            self.token_kinds.push(token.clone());
        }
    }

    pub fn add_token(&mut self, token: String) {
        self.token_kinds.push(token);
    }


    /// Lexer for UTF-8 text
    pub fn lex_utf8(&mut self) -> Vec<Token> {
        let chars = self.text.char_indices().collect::<Vec<(usize, char)>>();
        let mut tokens = Vec::new();
        let mut i = 0;
        let mut line = 0;
        let mut column = 0;
        let len = chars.len();
        'chars: while i < len {
            // Take new line into account
            if chars[i].1 == '\n' {
                line += 1;
                column = 0;
                tokens.push(Token {
                    index: chars[i].0,
                    len: 1,
                    location: TextLocation::new(line, column),
                    kind: TokenKinds::Control(ControlTokenKind::Eol),
                });
                i += 1;
                continue;
            }

            // Match token kinds
            for token_kind in &self.token_kinds {
                let mut token;
                let mut j: usize = 0;
                while i + j < len {
                    let start = chars[i].0;
                    let end = if i + j + 1 < len {
                        chars[i + j + 1].0
                    } else {
                        chars[i + j].0 + chars[i + j].1.len_utf8()
                    };
                    token = &self.text.as_bytes()[start..end];
                    if token == token_kind.as_bytes(){
                        tokens.push(Token {
                            index: chars[i].0,
                            len: j + 1,
                            location: TextLocation::new(line, column),
                            kind: TokenKinds::Token(token_kind.clone()),
                        });
                        i += j + 1;
                        column += j + 1;
                        continue 'chars;
                    }
                    j += 1;
                }
            }

            // Match whitespace
            if chars[i].1.is_whitespace() {
                tokens.push(Token {
                    index: chars[i].0,
                    len: 1,
                    location: TextLocation::new(line, column),
                    kind: TokenKinds::Whitespace,
                });
                i += 1;
                column += 1;
                continue;
            }

            // Match text until next whitespace/token/eof
            let mut j = 0;
            'word: while i + j < len {
                if chars[i + j].1.is_whitespace() {
                    break;
                }
                for token_kind in &self.token_kinds {
                    let start = chars[i + j].0;
                    let end = if i + j + 1 < len {
                        chars[i + j + 1].0
                    } else {
                        chars[i + j].0 + chars[i + j].1.len_utf8()
                    };
                    let token = &self.text.as_bytes()[start..end];
                    if token == token_kind.as_bytes() {
                        break 'word;
                    }
                }
                j += 1;
            }
            tokens.push(Token {
                index: chars[i].0,
                len: j,
                location: TextLocation::new(line, column),
                kind: TokenKinds::Text,
            });
            column += j;
            i += j;
        }
        tokens.push(Token {
            index: i,
            len: 0,
            location: TextLocation::new(line, column),
            kind: TokenKinds::Control(ControlTokenKind::Eof),
        });
        tokens
    }

    /// Lexer for ascii-only text
    pub fn lex_ascii(&mut self) -> Vec<Token> {
        let chars = self.text.as_bytes();
        let mut tokens = Vec::new();
        let mut i = 0;
        let mut line = 0;
        let mut column = 0;
        let len = chars.len();
        'chars: while i < len {
            // Take new line into account
            if chars[i] == '\n' as u8 {
                line += 1;
                column = 0;
                i += 1;
                tokens.push(Token {
                    index: i,
                    len: 1,
                    location: TextLocation::new(line, column),
                    kind: TokenKinds::Control(ControlTokenKind::Eol),
                });
                continue;
            }

            // Match token kinds
            for token_kind in &self.token_kinds {
                let mut token;
                let mut j = 0;
                while i + j < len {
                    token = &chars[i..i + j + 1];
                    if token == token_kind.as_bytes() {
                        tokens.push(Token {
                            index: i,
                            len: j + 1,
                            location: TextLocation::new(line, column),
                            kind: TokenKinds::Token(token_kind.clone()),
                        });
                        i += j + 1;
                        column += j + 1;
                        continue 'chars;
                    }
                    j += 1;
                }
            }

            // Match whitespace
            if (chars[i] as char).is_whitespace() {
                tokens.push(Token {
                    index: i,
                    len: 1,
                    location: TextLocation::new(line, column),
                    kind: TokenKinds::Whitespace,
                });
                i += 1;
                column += 1;
                continue;
            }

            // Match text until next whitespace/token/eof
            let mut j = 0;
            'word: while i + j < len {
                if (chars[i + j] as char).is_whitespace() {
                    break;
                }
                for token_kind in &self.token_kinds {
                    let start = i + j;
                    let end = if i + j + 1 < len {
                        i + j + 1
                    } else {
                        i + j
                    };
                    let token = &self.text[start..end];
                    if token == *token_kind {
                        break 'word;
                    }
                }
                j += 1;
            }
            tokens.push(Token {
                index: i,
                len: j,
                location: TextLocation::new(line, column),
                kind: TokenKinds::Text,
            });
            column += j;
            i += j;
        }
        tokens.push(Token {
            index: i,
            len: 0,
            location: TextLocation::new(line, column),
            kind: TokenKinds::Control(ControlTokenKind::Eof),
        });
        tokens
    }

    /// Takes a slice of tokens and returns a string of the text
    pub fn stringify_slice(&self, tokens: &[Token]) -> String {
        let start = match tokens.first() {
            Some(token) => token.index,
            None => return String::new(),
        };
        let end = match tokens.last() {
            Some(token) => token.index + token.len,
            None => return String::new(),
        };
        if start >= end {
            return String::new();
        }
        if end > self.text.len() {
            return String::new();
        }
        self.text[start..end].to_string()
    }

    pub fn stringify(&self, token: &Token) -> String {
        self.text[token.index..token.index + token.len].to_string()
    }
}
